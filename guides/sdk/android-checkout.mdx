---
title: "Android SDK Integration"
description: "Integrate Yuno payments into your Android app with Kotlin using Full Checkout, Seamless Checkout, or Jetpack Compose"
---

## Overview

The Yuno Android SDK provides a pre-built payment UI that handles payment method rendering, card tokenization, and 3DS authentication. It supports both Activity/Fragment (View-based) and Jetpack Compose integrations.

<Note>
The Android SDK maintains SAQ-A PCI compliance. Card data never touches your servers. The SDK fully supports Google's 16 KB ELF page alignment requirements for Android 15 / ARMv9 devices.
</Note>

## Prerequisites

- Android Studio Hedgehog (2023.1) or later
- Minimum SDK: API 21 (Android 5.0)
- Target SDK: API 34+
- Kotlin 1.9+ (Kotlin Gradle Plugin 1.4.0+)
- Gradle 8.0+ (Android Gradle Plugin 4.0.0+)
- Java 8 enabled
- AndroidX (not legacy support libraries)
- ProGuard 6.2.2+ (if using code shrinking)
- Yuno API keys ([Authentication](/getting-started/authentication))
- At least one payment method enabled in your [Dashboard](/platform/dashboard/connections)

## Installation

<Steps>
  <Step title="Add the Yuno Maven repository">
    In your project-level `settings.gradle.kts`:

    ```kotlin
    dependencyResolutionManagement {
        repositories {
            google()
            mavenCentral()
            maven { url = uri("https://yunopayments.jfrog.io/artifactory/snapshots-libs-release") }
        }
    }
    ```
  </Step>

  <Step title="Add the SDK dependency">
    In your app-level `build.gradle.kts`:

    ```kotlin
    dependencies {
        implementation("com.yuno.payments:android-sdk:{latest_version}")
    }
    ```

    <Tip>
    Check the [Release Notes](https://docs.y.uno/docs/release-notes-android) or the [Yuno Android SDK repository](https://github.com/yuno-payments/yuno-sdk-android) for the latest version.
    </Tip>
  </Step>

  <Step title="Sync Gradle">
    Click **Sync Now** in Android Studio or run:

    ```bash
    ./gradlew build
    ```
  </Step>
</Steps>

### Permissions

The SDK includes the `INTERNET` permission by default:

```xml
<uses-permission android:name="android.permission.INTERNET" />
```

## SDK initialization

Initialize the SDK in your `Application` class:

```kotlin
import android.app.Application
import com.yuno.payments.core.Yuno
import com.yuno.payments.core.YunoConfig

class YourApplication : Application() {

    override fun onCreate() {
        super.onCreate()

        Yuno.initialize(
            this,
            "your-public-api-key",
            config = YunoConfig()
        )
    }
}
```

Register the Application class in `AndroidManifest.xml`:

```xml
<application
    android:name=".YourApplication"
    ...>
</application>
```

### YunoConfig options

```kotlin
data class YunoConfig(
    val saveCardEnabled: Boolean = false,
    val language: YunoLanguage? = null,
    val styles: YunoStyles? = null
)
```

| Parameter | Type | Required | Default | Description |
|-----------|------|----------|---------|-------------|
| `saveCardEnabled` | `Boolean` | No | `false` | Show "Save card for future payments" checkbox |
| `language` | `YunoLanguage` | No | Device locale | UI language: `ENGLISH`, `SPANISH`, `PORTUGUESE`, `INDONESIAN`, `MALAY`, `THAI` |
| `styles` | `YunoStyles` | No | Yuno defaults | Custom UI appearance (colors, fonts, corner radius) |

<Note>
Starting from SDK version 2.11.0, `cardFlow` is no longer part of `YunoConfig`. Card flow configuration is handled exclusively through the CheckoutBuilder.
</Note>

<Warning>
Never embed your private secret key in the Android app. Use only the public API key for client-side initialization.
</Warning>

## Full Checkout

Full Checkout renders all enabled payment methods with a single call.

### Activity / Fragment

<Steps>
  <Step title="Create a checkout session (server-side)">
    Create a session from your backend:

    ```json
    // POST https://api-sandbox.y.uno/v1/checkout/sessions
    {
      "amount": { "currency": "USD", "value": 50.00 },
      "country": "CO",
      "merchant_order_id": "order-123",
      "workflow": "SDK_CHECKOUT"
    }
    ```

    Pass the `checkout_session` token to your Android app.

    <Tip>
    If your payment flow sends users to an external browser (3DS, bank redirects), set the `callback_url` when creating the checkout session.
    </Tip>
  </Step>

  <Step title="Start the checkout process">
    Call `startCheckout` inside `onCreate()` of the Activity that initializes the SDK:

    ```kotlin
    startCheckout(
        checkoutSession = "checkout_session_id",
        countryCode = "CO",
        callbackPaymentState = { paymentState, paymentSubState ->
            handlePaymentState(paymentState, paymentSubState)
        }
    )
    ```

    | Parameter | Type | Required | Description |
    |-----------|------|----------|-------------|
    | `checkoutSession` | `String` | Yes | Checkout session ID |
    | `countryCode` | `String` | Yes | ISO 3166-1 alpha-2 country code |
    | `callbackPaymentState` | `(String?, String?) -> Unit` | No | Callback for payment state updates |
    | `merchantSessionId` | `String?` | No | Merchant tracking identifier |
  </Step>

  <Step title="Add the payment methods view (Jetpack Compose)">
    Use `PaymentMethodListViewComponent` to display available payment methods:

    ```kotlin
    @Composable
    fun PaymentMethodListViewComponent(
        activity: Activity,
        modifier: Modifier? = null,
        onPaymentSelected: (Boolean) -> Unit,
        onUnEnrollSuccess: (Boolean) -> Unit = {}
    )
    ```

    ```kotlin
    var paymentMethodIsSelected by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .weight(1f)
            .verticalScroll(rememberScrollState())
    ) {
        PaymentMethodListViewComponent(
            activity = activity,
            onPaymentSelected = { isSelected ->
                paymentMethodIsSelected = isSelected
            },
            onUnEnrollSuccess = { success ->
                if (success) {
                    // Show confirmation snackbar
                }
            },
        )
    }
    ```

    <Warning>
    Always wrap `PaymentMethodListViewComponent` in a `Column` with `.verticalScroll(rememberScrollState())`. Without this, the list may not render or scroll properly.
    </Warning>
  </Step>

  <Step title="Start the payment">
    ```kotlin
    startPayment(
        showStatusYuno = true,
        callbackOTT = { ott ->
            // One-time token received — create payment on server
            ott?.let { createPaymentOnServer(it) }
        },
        callBackTokenWithInformation = { tokenModel ->
            // Token with additional payment method info
        }
    )
    ```

    | Parameter | Type | Description |
    |-----------|------|-------------|
    | `showStatusYuno` | `Boolean` | Show payment status screen in SDK |
    | `callbackOTT` | `(String?) -> Unit` | Callback with one-time token |
    | `callBackTokenWithInformation` | `(OneTimeTokenModel?) -> Unit` | Callback with detailed token info |
  </Step>

  <Step title="Create payment and continue">
    After receiving the OTT, create the payment on your server. Then call `continuePayment`:

    ```kotlin
    fun onPaymentCreated(sdkActionRequired: Boolean) {
        if (sdkActionRequired) {
            continuePayment(
                showPaymentStatus = true,
                callbackPaymentState = { paymentState, paymentSubState ->
                    handlePaymentState(paymentState, paymentSubState)
                }
            )
        }
    }
    ```

    <Warning>
    Always call `continuePayment()` when the API response has `sdk_action_required: true`. This handles 3DS challenges, redirects, and async payment flows.
    </Warning>
  </Step>
</Steps>

### Payment states

```kotlin
const val PAYMENT_STATE_SUCCEEDED = "SUCCEEDED"
const val PAYMENT_STATE_FAIL = "FAIL"
const val PAYMENT_STATE_PROCESSING = "PROCESSING"
const val PAYMENT_STATE_REJECT = "REJECT"
const val PAYMENT_STATE_INTERNAL_ERROR = "INTERNAL_ERROR"
const val PAYMENT_STATE_STATE_CANCELED_BY_USER = "CANCELED"
```

| State | Description | Action required |
|-------|-------------|------------------|
| `SUCCEEDED` | Payment completed successfully | Navigate to confirmation |
| `FAIL` | Payment failed | Show error, allow retry |
| `PROCESSING` | Async payment in progress | Show processing indicator |
| `REJECT` | Payment rejected | Show rejection reason |
| `INTERNAL_ERROR` | Server-side error | Show generic error |
| `CANCELED` | User cancelled | No action needed |

### Jetpack Compose

```kotlin
import com.yuno.payments.features.checkout.YunoFullCheckout
import com.yuno.payments.features.checkout.rememberCheckoutState

@Composable
fun CheckoutScreen(checkoutSession: String) {
    val checkoutState = rememberCheckoutState()

    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Button(
            onClick = {
                checkoutState.startFullCheckout(
                    checkoutSession = checkoutSession,
                    countryCode = "CO"
                )
            }
        ) {
            Text("Pay Now")
        }
    }

    YunoFullCheckout(
        state = checkoutState,
        onResult = { result ->
            when (result.status) {
                PaymentStatus.SUCCEEDED -> { /* Navigate to confirmation */ }
                PaymentStatus.FAILED -> { /* Show error */ }
                PaymentStatus.PROCESSING -> { /* Show processing */ }
                PaymentStatus.CANCELLED -> { /* Handle cancellation */ }
            }
        }
    )
}
```

## Seamless Checkout

Seamless Checkout gives you control over payment method selection while Yuno handles the payment form.

<Steps>
  <Step title="Retrieve available payment methods">
    ```kotlin
    Yuno.getPaymentMethods(
        checkoutSession = sessionToken,
        countryCode = "CO"
    ) { methods ->
        updatePaymentMethodList(methods)
    }
    ```
  </Step>

  <Step title="Register the seamless checkout launcher">
    ```kotlin
    private val seamlessLauncher = registerForActivityResult(
        SeamlessCheckoutLauncher()
    ) { result: SeamlessCheckoutResult ->
        handleResult(result)
    }
    ```
  </Step>

  <Step title="Launch for selected method">
    ```kotlin
    fun onPaymentMethodSelected(method: YunoPaymentMethod) {
        seamlessLauncher.launch(
            SeamlessCheckoutParams(
                checkoutSession = sessionToken,
                paymentMethodType = method.type,
                countryCode = "CO"
            )
        )
    }
    ```
  </Step>

  <Step title="Handle payment creation callback">
    ```kotlin
    class CheckoutActivity : AppCompatActivity(), YunoSeamlessListener {

        override fun yunoCreatePayment(
            oneTimeToken: String,
            tokenWithInformation: YunoTokenData
        ) {
            PaymentApi.createPayment(oneTimeToken) { success ->
                if (success) {
                    Yuno.continuePayment()
                }
            }
        }

        override fun yunoPaymentResult(result: PaymentResult) {
            handleResult(result)
        }
    }
    ```
  </Step>
</Steps>

## 3DS handling

The SDK handles 3D Secure authentication automatically. No additional code is required. The payment result callback receives the final outcome after 3DS completes.

<Tip>
Test 3DS flows in sandbox using Yuno's test card numbers. Check the [Testing guide](/guides/testing) for available test credentials.
</Tip>

## Google Pay

To enable Google Pay in the Yuno Android SDK:

<Steps>
  <Step title="Enable Google Pay in Yuno Dashboard">
    Navigate to **Dashboard > Settings > Payment Methods** and enable Google Pay.
  </Step>

  <Step title="Add Google Pay metadata to manifest">
    ```xml
    <application>
        <meta-data
            android:name="com.google.android.gms.wallet.api.enabled"
            android:value="true" />
    </application>
    ```
  </Step>

  <Step title="Pass Google Pay configuration">
    ```kotlin
    checkoutLauncher.launch(
        FullCheckoutParams(
            checkoutSession = sessionToken,
            countryCode = "US",
            googlePay = YunoGooglePayConfig(
                merchantName = "Your Store Name",
                countryCode = "US"
            )
        )
    )
    ```
  </Step>
</Steps>

### Google Pay payment status

For synchronous payment methods like Google Pay, when a user cancels or closes the wallet UI:

- **SDK Status**: Returns `CANCELED` (CANCELLED_BY_USER)
- **Backend payment status**: Remains `PENDING` until PSP timeout or merchant cancellation
- **Important**: The SDK will not return `REJECT` or `PROCESSING` in this scenario

## ProGuard rules

If you use code shrinking (R8/ProGuard), add these rules to your `proguard-rules.pro`:

```
# Yuno SDK
-keep class com.yuno.payments.** { *; }
-keepclassmembers class com.yuno.payments.** { *; }
-dontwarn com.yuno.payments.**

# Required for payment processing
-keep class com.google.android.gms.wallet.** { *; }
```

<Note>
The SDK ships with consumer ProGuard rules. These additional rules are only needed if you encounter obfuscation issues.
</Note>

## Customization

Customize the checkout appearance to match your app's design:

```kotlin
val appearance = YunoAppearance(
    primaryColor = Color.parseColor("#6200EE"),
    backgroundColor = Color.WHITE,
    textColor = Color.BLACK,
    errorColor = Color.parseColor("#E53E3E"),
    borderColor = Color.parseColor("#E0E0E0"),
    cornerRadiusDp = 12,
    elevation = 4f,
    fontFamily = "sans-serif-medium",
    fontSizeSp = 14,
    buttonStyle = ButtonStyle.ROUNDED
)

Yuno.initialize(
    this,
    "your-public-api-key",
    config = YunoConfig(styles = appearance)
)
```

| Property | Type | Description |
|----------|------|-------------|
| `primaryColor` | `Int` (Color) | Primary accent color for buttons, links, active states |
| `backgroundColor` | `Int` (Color) | Background color of the checkout sheet |
| `textColor` | `Int` (Color) | Primary text color |
| `errorColor` | `Int` (Color) | Color for error messages and invalid field states |
| `borderColor` | `Int` (Color) | Border color for input fields |
| `cornerRadiusDp` | `Int` | Corner radius in dp for cards and buttons |
| `elevation` | `Float` | Elevation in dp for the checkout sheet |
| `fontFamily` | `String` | Font family name |
| `fontSizeSp` | `Int` | Base font size in sp |
| `buttonStyle` | `ButtonStyle` | `ROUNDED` or `RECTANGULAR` |

### Dark mode

The SDK respects the system dark mode setting by default. Colors adapt automatically unless you provide explicit `YunoAppearance` overrides.

To force dark mode:

```kotlin
val appearance = YunoAppearance(
    forceDarkMode = true,
    primaryColor = Color.parseColor("#BB86FC"),
    backgroundColor = Color.parseColor("#121212"),
    textColor = Color.WHITE
)
```

### Localization

Supported languages: English, Spanish, Portuguese, Indonesian, Malay, Thai. Set via `YunoConfig.language`.

## Error handling

Handle SDK errors through the result callback:

```kotlin
private fun handlePaymentState(paymentState: String?, paymentSubState: String?) {
    when (paymentState) {
        "SUCCEEDED" -> navigateToConfirmation()
        "FAIL" -> showError("Payment failed. Please try again.")
        "PROCESSING" -> showProcessingState()
        "REJECT" -> showError("Payment was rejected.")
        "INTERNAL_ERROR" -> showError("An unexpected error occurred.")
        "CANCELED" -> { /* User cancelled */ }
    }
}
```

### Async payment methods (PIX)

For asynchronous methods like PIX, when a user closes the QR code window:

- **SDK Status**: Returns `PROCESSING`, optionally with sub-status `CLOSED_BY_USER`
- **Backend payment status**: Remains `PENDING` and QR code remains valid until expiry
- **Checkout session reuse**: Re-opening the same session can display the same valid QR code

## Testing in sandbox

<Steps>
  <Step title="Use sandbox environment">
    Use sandbox API keys during initialization.
  </Step>

  <Step title="Use test credentials">
    Use sandbox API keys from **Dashboard > API Keys > Sandbox**.
  </Step>

  <Step title="Test with Yuno test cards">
    Use Yuno-provided test card numbers to simulate different outcomes. See [Testing](/guides/testing).
  </Step>
</Steps>

<Note>
Sandbox transactions use simulated providers. Some payment methods may have limited availability in sandbox compared to production.
</Note>

## Troubleshooting

### SDK not initializing

- Verify `Yuno.initialize()` is called in `Application.onCreate()` before any Activity launches
- Confirm the public API key is correct and matches your environment
- Check that `minSdk` is set to 21 or higher in `build.gradle.kts`
- Ensure AndroidX is used (not legacy support libraries)

### Checkout not appearing

- Ensure the checkout session token is valid and not expired
- Verify the Activity is not finishing when launching checkout
- Check that at least one payment method is enabled in Dashboard for the specified country
- Confirm the `FullCheckoutLauncher` is registered before `onCreate()` completes

### Build errors

- **Duplicate classes**: Add `exclude` rules for conflicting dependencies
- **Desugaring issues**: Enable core library desugaring in `build.gradle.kts`:

```kotlin
android {
    compileOptions {
        isCoreLibraryDesugaringEnabled = true
    }
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.4")
}
```

### Payment failing silently

- Implement the `callbackPaymentState` to capture all outcomes
- Enable verbose logging by checking Logcat with tag filter `YunoSDK`
- Verify you are calling `continuePayment()` when `sdk_action_required` is `true`

### Fragment lifecycle conflicts

If using Fragments, register the launcher in `onCreate()` (not `onViewCreated()`):

```kotlin
class CheckoutFragment : Fragment() {
    // Register in class body or onCreate — NOT in onViewCreated
    private val checkoutLauncher = registerForActivityResult(
        FullCheckoutLauncher()
    ) { result -> handleResult(result) }
}
```

<Warning>
Registering launchers after the Fragment is `STARTED` causes an `IllegalStateException`.
</Warning>

### PaymentMethodListViewComponent not rendering

- Ensure the component is wrapped in a scrollable `Column`
- Verify `startCheckout()` was called before displaying the component
- Check that the checkout session has available payment methods for the given country

## Next steps

<CardGroup cols={2}>
  <Card title="Mobile SDK Overview" icon="mobile" href="/guides/sdk/mobile-overview">
    Compare all mobile SDK options.
  </Card>
  <Card title="iOS SDK" icon="apple" href="/guides/sdk/ios-checkout">
    Building for iOS? Start here.
  </Card>
  <Card title="Android SDK Reference" icon="book" href="/guides/sdk/android-reference">
    Full parameter reference for the Android SDK.
  </Card>
  <Card title="Testing" icon="vial" href="/guides/testing">
    Test card numbers and sandbox setup.
  </Card>
</CardGroup>